---
title: 热更概述
author: MycroftCooper
created: 2025-04-28 02:36
lastModified: 2025-04-28 02:36
tags: 
category: 缓存区
note status: 草稿
---


# 1. 什么是热更新？

**热更新**（Hot Update）是一种在**不重新发布完整客户端**的情况下，对游戏进行内容或逻辑更新的方法。热更新可以分为 **资源热更新** 和 **代码热更新** 两种：

- **资源热更新**：用于更新游戏中的美术、音效、地图、模型等静态资源。
- **代码热更新**：用于更新游戏逻辑，如脚本、功能、Bug 修复等，避免重新提交新版本。

# 2. 资源热更新的三种方式

资源热更新可以分为 **整包更新、补丁更新、增量更新** 三种方式。

## **2.1 整包更新（Full Package Update）**

### **特点**

- 将**所有资源**重新打包成一个完整的新版本，上传到服务器，客户端下载后替换旧资源。
- 适用于**资源变动较大的更新**，如版本大更新。

### **优缺点**

✅ **简单易维护**，不需要维护多个资源版本。 

✅ **不会产生版本碎片化**，所有玩家资源一致。 

❌ **更新流量大**，即使只修改了少量资源，也需要下载整个包。 

❌ **下载时间长**，可能影响玩家体验。

### **适用场景**

- 游戏初期或大版本更新（如新赛季、新资料片）。
- 资源变更较大，不适合增量更新的情况。

### **操作流程**

1. 重新打包所有游戏资源。
2. 将新资源包上传至 CDN 服务器。
3. 客户端检测版本变化，下载并替换旧资源。
4. 启动游戏，加载新资源。

## **2.2 补丁更新（Patch Update）**

### **特点**

- **版本级别更新**：客户端需要按照 Patch 版本升级，不能跳版本（除非提供合成 Patch）。
- **维护多个版本的补丁**：服务器需要存储多个补丁包，如 V1 → V2，V2 → V3。
- **支持回滚**：如果某个版本更新后有问题，可以回退到上一个版本。

### **优缺点**

✅ **版本一致性强**，所有玩家的游戏版本完全相同，避免兼容性问题。如电竞、竞技类游戏，对版本一致性要求高。
✅ **支持回滚**，如果最新版本有 bug，可以快速回退到上一个稳定版本。

❌ **客户端需要依次更新多个 Patch**，更新步骤可能较复杂。 

❌ **服务器存储压力大**，需要维护多个版本的补丁。

### **适用场景**

- 适用于**端游、主机游戏、电竞游戏**，保证版本稳定性。
- 适用于**对平衡性要求高的游戏**，如 FPS、MOBA 竞技游戏（如《英雄联盟》《CS:GO》）。
- 适用于**需要支持历史版本的游戏**，如单机游戏 DLC 需要支持老玩家升级到新版本。

### **操作流程**

1. 计算旧版本与新版本的资源差异，生成 Patch 文件。
2. 服务器存储多个版本的 Patch（如 V1→V2、V2→V3）。
3. 客户端根据当前版本**逐步下载并应用 Patch**。
4. 版本更新完成，进入游戏。

### **典型案例**

- **《英雄联盟》**：使用 **版本 Patch 更新**，每次新赛季推出时，必须更新完整 Patch，保证所有玩家版本一致。
- **《魔兽世界》**：暴雪战网提供**补丁更新机制**，玩家必须下载完整 Patch 进行版本更新。

## **2.3 增量更新（Incremental Update）**

### **特点**

- **文件级别更新**：只更新变化的资源，不关心版本。

- **实时检查资源差异**：客户端比对本地资源的 Hash，与服务器上的最新资源进行对比，决定是否下载新的资源。

  **资源可单独下载和替换**：无需整体替换或补丁合成。

### **优缺点**

✅ **下载量最小**，只获取必要的资源。 

✅ **更新速度快**，无需多次下载 Patch。 

✅ **维护成本低**，服务器端只存最新的资源文件。

❌ **无法回滚**，如果出现问题，通常需要完整重新下载资源或回退整个客户端。

❌ **版本管理复杂**，不同客户端可能有不同资源版本，需要服务器维护资源版本列表。 

❌ **可能产生资源碎片**，需要定期清理无用资源。

### **适用场景**

- 适用于**更新频繁、但资源变更较少的游戏**（如每周更新少量新地图或角色皮肤）。
- 适用于**CDN 分发的游戏**，可以按需加载不同资源，减少初始安装包大小。
- **手游**（如《原神》《王者荣耀》），减少下载量。
- **开放世界、MMORPG**，如《GTA Online》长期运营的多人在线游戏，支持动态扩展内容。

### **典型案例**

- **《原神》**：使用 **远程资源 + AssetBundle** 实现增量更新，玩家只下载新增或修改的场景、角色等数据。
- **《王者荣耀》**：使用**增量更新 + 资源校验**，每个版本仅下载新增或修改的皮肤、英雄数据。

### **操作流程**

1. 服务器提供资源版本索引（Hash 校验）。
2. 客户端检查本地资源，计算需要更新的资源。
3. 仅下载有变化的资源文件，并替换旧文件。
4. 资源更新完成，进入游戏。

## **2.4 资源热更总结**

### **什么时候选整包更新？**

- **游戏初期或大版本更新**（如新赛季、新资料片），所有玩家需要统一的完整资源。
- **资源大规模变更**（如 UI 重制、游戏引擎升级、角色模型大改动）。
- **开发阶段的重大调整**，如更换核心美术资源或大规模优化性能。
- **玩家网络条件允许时**，例如**主机/PC 端游**，整包更新不会对玩家体验造成过大影响。

### **什么时候选增量更新？**

- 游戏资源变化小，但更新频繁（如手游、开放世界游戏）。
- 需要**降低下载流量**，避免大版本更新（如王者荣耀、原神）。
- 采用**CDN 分发资源**，支持按需加载。

### **什么时候选补丁更新？**

- 需要**保证版本一致性**，防止玩家因资源不同导致问题（如电竞游戏）。
- 需要**支持回滚**，方便修复问题（如 PC 端游）。
- 适用于**大型游戏**，特别是 PC/主机平台。

### **有时游戏需要兼顾三种方案**

一些游戏会结合**增量更新、补丁更新、整包更新**三种方案：

- **手游（王者荣耀、原神）**：主要使用**增量更新**，但关键版本更新时结合**补丁更新**，在重大更新时采用**整包更新**。
- **端游（魔兽世界、英雄联盟）**：通常使用**补丁更新**，但小型资源（如皮肤、DLC）可能使用**增量更新**，在引擎大改或资料片更新时使用**整包更新**。
- **大型主机/开放世界游戏（如《赛博朋克 2077》《荒野大镖客2》）**：大版本时采用**整包更新**，定期小更新采用**补丁更新**，DLC 资源可能使用**增量更新**。

选择合适的组合方案，可以平衡更新效率、资源管理和玩家体验！

### 三种资源热更新对比总结表

| 对比项           | **增量更新（Incremental Update）**                           | **补丁更新（Patch Update）**                                 | **整包更新（Full Package Update）**                          |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **更新方式**     | 直接更新变更的单个资源（文件级别）                           | 生成新旧版本之间的差异补丁                                   | 生成完整资源包，覆盖原有资源                                 |
| **更新策略**     | 仅下载最新的有变更资源，不关心版本                           | 客户端必须按版本顺序或跳跃合成进行更新                       | 客户端下载完整资源包，直接覆盖                               |
| **文件组织方式** | 资源文件通常按**独立文件** 形式存放（如 AssetBundles、Pak、单个文件等） | 资源文件被封装成 Patch 包，客户端按版本升级                  | 所有资源整合到一个大文件或多个大资源包                       |
| **资源管理**     | 需要维护资源文件列表（通常带有版本号、Hash 校验）            | 需要维护多个版本的 Patch（从 V1 → V2、V2 → V3）              | 只需维护最新的完整资源包，不关注历史版本                     |
| **服务器存储**   | 仅存储最新的资源，无需保留旧版本                             | 需要存储多个补丁文件，以支持不同版本的升级路径               | 只存储最新完整包，空间占用较大                               |
| **客户端存储**   | 只保留最新资源，不会留下旧文件                               | 可能需要保留部分旧资源，以便逐步升级                         | 只保留最新完整资源包，存储空间占用大                         |
| **网络流量**     | 只下载变化的资源，流量消耗低                                 | 需要下载完整的 Patch，可能包含部分冗余资源                   | 下载完整资源包，流量消耗最大                                 |
| **更新速度**     | **更快**（下载少量文件，通常是资源级别）                     | **较慢**（如果需要多次下载 Patch，累计下载量可能较大）       | **最慢**（需要下载完整资源包）                               |
| **回滚机制**     | **较难实现**（需要重新下载旧版本资源）                       | **更容易**（可以下载旧版本 Patch 进行回退）                  | **无回滚**（需要重新下载旧版本完整包）                       |
| **维护难度**     | **低**，服务器端存储较少，只需提供最新资源                   | **高**，需要维护多个 Patch 版本，并确保客户端能够正确应用    | **低**，只需维护最新完整资源包                               |
| **适用场景**     | **开放世界游戏**（如《原神》）- **多人在线游戏（MMORPG）**- **长期运营游戏（如手游）**- **内容扩展频繁的游戏（如 DLC）** | **大型端游/主机游戏（如 Steam 游戏）**- **有版本依赖的游戏（如 FPS、RPG）**- **对版本一致性要求高的游戏（如电竞游戏）** | **游戏初期或大版本更新**（如赛季更新、资料片）- **资源大改动**（如 UI、建模重制） |
| **典型案例**     | Unity 的 AssetBundle，Unreal Engine 的 Pak System            | Steam、战网的 Patching System，PC 端游更新系统               | 传统 PC 端游、手游大版本更新                                 |

# 3. 代码热更新

## 3.1 InjectFix

### 3.1.1 InjectFix 概述

InjectFix 是一种 **C# 代码热更新方案**，它使用 **IL 级别的 Patch 机制** ，允许在 **运行时使用新的 IL 代码替换旧代码。**

InjectFix 可以 **动态替换已有的方法**，并支持 **新增方法和字段**，但不能新增类。

> InjectFix GitHub:
> [GitHub - Tencent/InjectFix: InjectFix is a hot-fix solution library for Unity](https://github.com/Tencent/InjectFix?tab=readme-ov-file)

### 3.1.2 工作原理

InjectFix 通过以下步骤实现代码热更新:

1. **在开发阶段，给目标函数添加** `[Patch]` **标记**

   1. 在需要热更的方法上添加 `[Patch]` 特性，例如：

      ```c#
      public class Player{    
          public int GetHealth(){        
              return 100;    
          }
      }
      
      [Patch]
      public int GetHealthPatched(){
          return 200;
      }
      ```

   2. **InjectFix 编译时会自动扫描所有** `[Patch]` **方法，并记录需要热更的函数信息。**

2. 生成热更 Patch（打包阶段）

   1. **InjectFix 编译热更的目标代码时，会将带** `[Patch]` **标记的函数的 IL 代码提取出来，转换成二进制格式** `hotfix.bytes`**。**

   2. `hotfix.bytes` **文件包含新方法的 IL 代码，InjectFix 在运行时会解析这个文件。**

   3. **同时，InjectFix 可能会生成一个** `version.json` **文件，记录热更版本信息，确保热更文件的正确性。**

   4. **热更包（包含** `hotfix.bytes` **和** `version.json`**）会上传到 CDN 服务器或其他资源服务器，以供客户端下载。**

3. 运行时加载 Patch（玩家启动游戏后）

   1. **客户端在启动时，先检查是否有新的** `hotfix.bytes` **需要下载。**

   2. **如果有新的热更 Patch，InjectFix 会从服务器下载** `hotfix.bytes`**，并存储到本地。**

   3. **游戏运行时，InjectFix 解析** `hotfix.bytes`**，加载新的 IL 代码。**

4. InjectFix 运行时替换目标方法

   1. **InjectFix 使用反射 (**`MethodInfo`**) 找到原方法**

      ```
      MethodInfo oldMethod = typeof(Player).GetMethod("GetHealth");
      ```

   2. **InjectFix 通过** `MethodInfo` **修改** `methodPointer`**，让原方法的执行指向新的 IL 代码。**

      ```
      InjectFix.Runtime.ReplaceMethod(oldMethod, newILCode);
      ```

   3. **在 IL2CPP 下，由于方法已经被编译成 C++，InjectFix 不能直接修改 C++ 代码，而是拦截方法调用，让它跳转到 InjectFix 内部的 IL 解释器执行新的 IL 代码。**

   4. **InjectFix 在运行时解析** `hotfix.bytes` **并执行新的 IL 代码，原始** `GetHealth()` **方法的执行逻辑被** `GetHealthPatched()` **替换。**

5. 代码热更生效（玩家运行时）

   1. **玩家调用** `GetHealth()` **方法时，实际上执行的是** `GetHealthPatched()` **方法的 IL 代码。**

   2. **即使原来的** `GetHealth()` **已经被编译成 C++，InjectFix 也能确保** `GetHealth()` **运行的是新的逻辑。**

   3. 整个过程对玩家是透明的，不需要重新启动游戏或重新安装新版本。

### 3.1.3 局限性

- **不能新增类**

  - **InjectFix 只能 Patch 现有类，而不能新增新的类（Type）**。

  - **如果想在热更中创建新** `class`**，InjectFix 无法做到。**

- **不能热更泛型方法**

  ```
  public T GetData<T>(T value){    
        return value;
  }
  ```

  - **InjectFix 无法正确解析泛型方法**，它只能处理普通方法。

  - **在 IL2CPP 下，泛型方法可能根本不会有** `MethodInfo`**，InjectFix 无法 Hook。**

- **不能热更 Lambda 表达式**

  ```
  Func<int, int> Add = x => x + 1;
  ```

  - **Lambda 在 IL2CPP 下可能被优化掉，导致 InjectFix 无法找到** `**MethodInfo**`。

  - **Lambda 表达式会被转换成匿名类（Closure 类），InjectFix 无法 Hook 匿名类方法**。

- **不能热更事件（Event）**

  ```
  public event Action OnDamage;
  ```

  - **事件本质上是** `add_OnDamage()` **/** `remove_OnDamage()` **方法，可能被 IL2CPP 内联优化**。

  - **InjectFix 不能 Hook** `add_OnDamage()`**，所以无法替换事件的行为**。

- 因为使用反射，所以性能很差，**不能热更高频代码**(例如Update)

### 3.1.4 现状

- 适用于 **简单的小规模热修复（Bug 修复）**，不适合完整的 C# 热更新

- 已停止维护，**InjectFix 最后一次更新在 3 年前**

- **如果需要更高性能和更好的 IL2CPP 支持，建议使用 HybridCLR**
  **许多游戏已从 InjectFix 迁移到 HybridCLR**

**InjectFix 与 HybridCLR 比较**

InjectFix 被大量放弃的重要原因，是 **HybridCLR 提供了更强大的热更新能力**，且 **IL2CPP 下性能更优秀**。

| **特性**                     | **InjectFix**             | **HybridCLR**                         |
| ---------------------------- | ------------------------- | ------------------------------------- |
| **是否支持 IL2CPP**          | ✅ **支持（解释执行 IL）** | ✅ **支持（直接运行 AOT + JIT 代码）** |
| **是否能新增类**             | ❌ **不能**                | ✅ **可以**                            |
| **是否能新增方法**           | ✅ **可以**                | ✅ **可以**                            |
| **是否能新增字段**           | ✅ **可以**                | ✅ **可以**                            |
| **是否能热更泛型方法**       | ❌ **不能**                | ✅ **可以**                            |
| **是否能热更 Lambda 表达式** | ❌ **不能**                | ✅ **可以**                            |
| **是否能热更事件（event）**  | ❌ **不能**                | ✅ **可以**                            |
| **执行性能**                 | **低（IL 解释执行）**     | **高（AOT + JIT 直接运行）**          |
| **适用于完整的 C# 热更新**   | ❌ **不能**                | ✅ **可以**                            |

## 3.2 HybridCLR

### 3.2.1 HybridCLR概述

HybridCLR 是一个基于 Unity 生态的高性能热更新方案，它借鉴了 Mono 的 **mixed mode execution**（混合模式执行）技术，为 **il2cpp** 生成的 AOT（Ahead of Time）环境提供了解释器（Interpreter）支持，使其能执行未 AOT 预编译的 C# 代码。

其核心思想是通过“**AOT + 解释执行**”的混合模式，让 Unity 项目能够在 il2cpp 环境下支持热更新，而无需采用传统的 **Mono 运行时**。

在 Unity 中，il2cpp 主要是为了提高性能和安全性，但它的一个主要限制是 **不支持直接运行动态编译的代码**（如 C# 的 `Assembly.Load`）。HybridCLR 通过添加解释执行能力，允许 **部分代码在运行时加载和执行**，从而支持热更新能力。

> HybridCLR GitHub仓库
> https://github.com/focus-creative-games/hybridclr

**HybridCLR 解决了什么问题？**

在 Unity **IL2CPP（AOT）模式** 下，默认 **不能动态加载 C# DLL**：

- **不能用 `Assembly.Load()` 加载新的 DLL**
- **不能用反射创建动态类型**
- **不能热更泛型方法**
- **不能 JIT 运行新的 IL 代码**

HybridCLR 解决了这些问题，它允许： 

✅ **IL2CPP 运行新的 IL 代码** 

✅ **支持 `Assembly.Load()` 动态加载 C# DLL** 

✅ **支持完整的 C# 热更，包括新增类、泛型、事件等**

 ✅ **性能比 InjectFix 更高**

**优点**

1. **支持热更新**：
   在 Unity il2cpp 环境下运行 C# 代码，并支持动态加载新的代码逻辑。
2. **运行时效率高**：
   相比纯解释器方案（如 xLua），HybridCLR 结合了 AOT 和解释器执行模式，**性能更优**。
3. **跨平台支持好**：
   由于基于 il2cpp，HybridCLR 能支持 Unity 能运行的所有平台，包括 iOS、Android、PC 端等。
4. **兼容性强**：
   可以直接复用 Unity 原生的 il2cpp 代码生成逻辑，无需大改项目结构。
5. **开发体验优良**：
   在开发时可以直接运行 C# 代码，不影响原本的开发体验。

**缺点**

1. **初始学习成本较高**：
   需要理解 **AOT、JIT、解释器** 等概念，并掌握 HybridCLR 的工作方式。
2. **部分功能需要手动适配**：
   部分复杂的反射、泛型代码可能需要特别处理，以避免解释器执行时性能下降。
3. **解释器性能相对 AOT 代码较低**：
   虽然解释执行能力强，但 Interpreter 仍然比 AOT 代码慢，不适合高性能计算逻辑。

### 3.2.2 **工作原理**

HybridCLR 主要借鉴了 **Mono 的 mixed mode execution** 技术，在 Unity il2cpp 环境中增加了解释执行能力。

其核心机制如下：

1. **元数据解析**：
   HybridCLR 解析 **未 AOT 预编译的 C# DLL**（即热更 DLL），并动态注册到运行时中。
2. **解释执行**：
   如果某个方法 **没有被 AOT 预编译**，HybridCLR 通过解释器执行该方法。
3. **编译优化：**
   - **优先执行 AOT 代码**：
     已经被 il2cpp 预编译的方法，仍然按原有 AOT 方式执行，保证性能。
   - **未 AOT 代码则解释执行**：
     对于新增的代码，HybridCLR 采用解释执行模式运行。
4. **跨 DLL 交互**：
   热更代码可以调用 AOT 代码，反之亦然。

### 3.2.3 热更运行流程

1. **游戏启动时，加载 AOT 代码**（il2cpp 预编译的代码）。
2. **解析 HybridCLR 需要的热更 DLL**（通常是 `Logic.dll`）。
3. **如果 AOT 代码里找不到某个方法，就进入 HybridCLR 解释器执行**。
4. **通过反射、泛型等机制，动态绑定新逻辑**。
5. **更新逻辑时，只需更换热更 DLL 即可，不影响 AOT 代码**。

### 3.2.4 HybridCLR 实际使用流程

这里以 **Unity 热更新一个新的业务逻辑** 为例，演示 HybridCLR 的基本使用流程。

1. 配置 HybridCLR
   首先，在 Unity 项目中安装 HybridCLR：
   1. 通过 `git clone` 下载 HybridCLR 相关的工具和代码。
   2. 在 Unity 编辑器中 **安装 HybridCLR 插件**。
   3. **配置 HybridCLR 需要的 AOT 元数据**（即需要保留的 AOT 类型）。

2. 生成 AOT 和热更 DLL
   1. **AOT 代码**：
      1. 在 `Assembly-CSharp` 项目中写入核心逻辑（不会变更的）。
      2. 让 Unity 编译这些代码，并生成 `Assembly-CSharp.dll`。
      3. 运行 `il2cpp`，生成 AOT 二进制文件。
   2. **热更代码**：
      1. 新建 `Logic.dll`，用于放置 **可热更新的代码**。
         在 Logic.dll 里写入新业务逻辑，例如一个新的 UpdateSystem类：

```c#
public class UpdateSystem{
    public static void Run(){
        Console.WriteLine("新业务逻辑运行中...");
    }
}
```

- 通过 `dotnet build` 编译 `Logic.dll`，但 **不进行 AOT 编译**，以便运行时动态加载。

3. 运行时加载新 DLL
   在 Unity 运行时，加载 `Logic.dll` 并执行：

```c#
var assembly = System.Reflection.Assembly.Load(File.ReadAllBytes("Logic.dll"));
var type = assembly.GetType("UpdateSystem");
var method = type.GetMethod("Run");
method.Invoke(null, null);
```

HybridCLR 会解析 `Logic.dll` 的元数据，并动态执行 `Run()` 方法。

4. 未来热更
   如果需要 **修复 bug 或增加功能**：
   1. 修改 `Logic.dll` 代码，例如 

```
Run()
```

​	 方法新增日志：

```c#
public class UpdateSystem{
    public static void Run(){
        Console.WriteLine("新业务逻辑更新了！新增功能！");
    }
}
```

	2. **重新编译 `Logic.dll` 并替换**。
	2. **游戏启动后会自动加载新 DLL，无需重新打包整个应用**。
