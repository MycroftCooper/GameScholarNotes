# Unity多线程开发

# 1. 多线程理论知识

## 1.1 什么是多线程

**线程（Thread）是程序执行的最小单位**

- 一个程序（Process）可以包含多个线程。
- 多个线程可以**并发（Concurrent）**执行任务。

> 举个例子：你是一个人（进程），你可以同时用一只手打字、一只手喝水（线程）。

### 单线程 vs 多线程

- **单线程**：一次只能做一件事，任务按顺序进行。
- **多线程**：可以“同时”做多件事（注意是并发，不一定是真并行）。

通俗理解：一个人做事 vs 一群人分工协作。

### 并发vs并行

**并发：**
看起来“同时进行”，其实 CPU 快速切换。
例如：快速轮流做饭、刷碗、打电话

**并行：**
真正“同时进行”，需要多核 CPU
多人分工合作，同时做饭和打扫卫生

> 多线程在单核 CPU 上是并发，在多核 CPU 上才可能是并行。

### 程序，进程，线程，协程

**程序（Program）**
一组指令的集合，保存在磁盘上的可执行文件，如 `.exe` 文件。尚未运行。

**进程（Process）**
程序运行后在内存中的实例，是资源分配的基本单位。每个进程有自己独立的内存空间。

**线程（Thread）**
进程中的执行单元，是真正“运行代码”的东西。一个进程可包含多个线程。

**协程（Coroutine）**
一种轻量级的“伪线程”，在主线程中被调度，用于处理异步任务或逻辑流程。

| 对比项         | 程序（Program） | 进程（Process）                | 线程（Thread）           | 协程（Coroutine）                       |
| -------------- | --------------- | ------------------------------ | ------------------------ | --------------------------------------- |
| 是否运行       | ❌ 静态文件      | ✅ 正在运行                     | ✅ 正在执行任务           | ✅ 控制流程（由线程执行）                |
| 是否有内存空间 | ❌ 没有          | ✅ 独立内存空间                 | ❌ 共享进程的内存空间     | ❌ 和线程共用主线程内存                  |
| 是否可并行     | ❌ 不可          | ✅ 多进程间可并行               | ✅ 多线程可并行（多核）   | ❌ 不可并行（伪并发，在主线程排队执行）  |
| 创建开销       | 低              | 高（操作系统资源）             | 中（上下文切换）         | 低（协程调度由程序控制）                |
| 调度方式       | N/A             | 由操作系统调度                 | 由操作系统调度           | 由程序（如 Unity）手动调度（yield控制） |
| 示例           | `MyApp.exe`     | Windows 任务管理器里的某个进程 | 线程池里的线程，下载线程 | Unity 中的 `IEnumerator` 协程           |

比如你在运行一个 Unity 游戏：

- 程序：游戏安装包里的 `.exe` 文件
- 进程：你点击 `.exe` 启动的游戏进程，占用一块内存
- 线程：游戏主线程（渲染、更新逻辑）、音频线程、加载线程等
- 协程：Unity 的 `IEnumerator`，控制一段动画播放暂停继续

### 多线程有什么用？

**提高程序响应速度**

- **提升 CPU 利用率（尤其是多核处理器）**
-  **支持后台处理耗时任务**
- **更自然地建模复杂行为（如游戏AI、物理、网络）**

**在 Unity 中常见的使用场景：**

- 后台加载资源（避免卡顿）
- 网络请求响应
- 游戏 AI 批量计算
- 音频数据处理、地图生成、寻路运算

## 1.2 多线程的原理

这一部分我们来搞清楚多线程**是怎么运作的**，包括操作系统如何调度线程、什么是上下文切换、线程与CPU核心的关系等。

**关键理解：**
多线程的“同时运行”本质上是**CPU在多个线程之间快速切换执行**，让我们感觉它们是“同时”在跑。

这背后离不开两个关键机制：

- **线程调度器（Thread Scheduler）**：决定哪个线程什么时候运行。
- **上下文切换（Context Switch）**：CPU 保存当前线程状态，切到另一个线程运行。

### CPU 核心 & 线程调度

**多核 CPU 支持“真正的并行”：**

- 单核 CPU：多个线程**轮流**使用 CPU（并发）
- 多核 CPU：多个线程可以**同时**运行在不同核心上（并行）

> 比如 4 核 CPU 可以同一时间真正执行 4 个线程，其余线程排队等待。

**线程调度：**

线程不是你一写就跑，它的执行要经过 **操作系统调度器（如 Windows 的线程管理器）** 的调度：

- 每个线程会被分配一个**时间片**（time slice），一般为几毫秒。
- 到了时间片后，CPU 就**保存当前线程状态**，切换到下一个线程。
- 系统会根据优先级、线程状态（就绪/阻塞/运行）动态决定哪个线程获得 CPU 时间。

### 上下文切换（Context Switching）

当 CPU 从一个线程切换到另一个线程时，需要保存当前线程的状态（寄存器、堆栈等），再加载新线程的状态。这一整个过程就叫**上下文切换**。

- 每个线程有自己的寄存器、堆栈等，CPU 需保存当前状态，切换到另一个线程。
- 保存和恢复上下文需要时间。
- 频繁切换会拖慢系统性能，导致“线程多未必更快”。

### 线程的生命周期



## 线程安全与线程同步

###  什么是线程安全？

如果一个函数/模块在**多个线程同时访问时仍能保证数据正确性**，它就是线程安全的。

```
csharp复制编辑// 非线程安全
counter++; // 多线程下可能读取同一个值，结果被覆盖

// 线程安全（加锁）
lock(myLock) {
    counter++;
}
```

### 🔹 为什么会出现线程不安全？

因为线程可能“同时”访问和修改**共享资源**（如变量、文件、列表等），导致：

- 脏数据（数据被篡改）
- 丢失更新（最后写入值错误）
- 死锁/活锁（线程互相等待/循环不前）

### 线程锁



### 线程同步问题

#### 死锁

两个线程互相等待对方释放锁，造成程序卡死。

#### 活锁

线程不断尝试但始终失败，导致逻辑无法前进。

#### 竞态条件

结果依赖线程执行顺序，导致随机Bug。



# Unity多线程开发方案

在 Unity 中使用 C# 进行多线程开发可以有效提升性能，特别是在处理大量计算或IO操作时。Unity 本身的主线程是单线程模型，大多数 Unity API（尤其是渲染和GameObject操作）只能在主线程调用，所以多线程使用需谨慎设计。

以下是常用的多线程技术方案、原理、优缺点和适用场景分析：

## 1. `System.Threading.Thread`

### 原理：

- 使用底层线程创建机制，手动创建一个新线程执行任务。

```c#
Thread thread = new Thread(() => { /* your work */ });
thread.Start();
```

### 优缺点：

**优点：**

- 控制细致，可完全管理线程生命周期。
- 适合对线程有定制化需求的场景。

**缺点：**

- 手动管理线程，复杂易错。
- 创建线程开销大，线程数过多会拖慢性能。
- 不支持线程池，线程无法重用。

### 适用场景：

- 少量长期任务，线程管理逻辑简单。
- 不依赖 Unity API 的耗时逻辑，如本地文件读写、网络请求、数学计算等。

------

## 2. `System.Threading.ThreadPool`

### 原理：

- 使用线程池复用已有线程执行任务，避免频繁创建/销毁线程。

```c#
ThreadPool.QueueUserWorkItem(_ => { /* your work */ });
```

### 优点：

- 线程复用，性能更优。
- 适合大量短小任务。
- 系统自动管理线程。

### 缺点：

- 无法控制线程生命周期（如暂停、取消）。
- 无法设置线程优先级。
- 任务不保证执行顺序。

### 适用场景：

- 高并发但任务短小的后台任务。
- JSON 解析、压缩解压、Hash计算等。

## `Parallel.For` / `Parallel.ForEach`

### 🔧 原理：

- 利用线程池，**自动分配多个线程**并行执行循环体（通常是 `for` 或 `foreach`）。
- 线程调度由 .NET 的 `TaskScheduler` 管理，**并发执行、但同步等待所有线程完成**，所以它是**阻塞主线程的**。

```
csharp复制编辑Parallel.For(0, 1000, i => {
    // 并行执行这段代码
});
```

### ✅ 优点：

- 编写简单，适合 CPU 密集型批处理。
- 自动分配线程池资源，免管理。
- 能大大加速大批量计算操作。

### ❌ 缺点：

- **是阻塞式的！主线程会等待它完成。**
- 不适用于 Unity 主线程（因为会卡顿掉帧）。
- 无法取消或暂停执行。
- 不适合使用 Unity API（会崩）。

### 🔧 适用场景：

- 非 Unity 主线程环境下做批处理计算。

- Unity 中配合 `Task.Run` 使用来避免主线程阻塞：

  ```
  csharp复制编辑Task.Run(() => {
      Parallel.For(0, 10000, i => {
          // 纯计算逻辑
      });
  });
  ```

------

## 🚫 注意在 Unity 中的用法

在 Unity 的主线程中 **直接调用 `Parallel.For` 是不推荐的**，因为它会导致**主线程卡死直到并行计算完成**。推荐做法是放在 `Task.Run()` 之类的异步任务中，然后通过 `await` 等方式回到主线程更新状态。

```
csharp复制编辑async void RunParallelJob() {
    await Task.Run(() => {
        Parallel.For(0, 10000, i => {
            // Heavy CPU-bound work
        });
    });
    Debug.Log("计算完成");
}
```

## 3. `Task` / `async-await`（推荐）

### 原理：

- 使用 `Task` 封装异步任务，通过 `async/await` 实现非阻塞调用。
- 底层由 `ThreadPool` 驱动，使用状态机方式调度任务。

```c#
async Task DoSomethingAsync() {
    var result = await Task.Run(() => {
        // Heavy work here
        return "result";
    });
}
```

### 优点：

- 语法简洁，易读易写。
- 支持链式调用，异常处理也方便。
- 与 `ThreadPool` 类似的高性能。

### 缺点：

- 不适合需要精细线程控制的场景。
- 初学者容易滥用 async/await 造成状态混乱。
- `await` 中不能调用 Unity API。

### 适用场景：

- 大多数 Unity 后台异步任务（数据处理、网络、IO等）。
- 与 `UnityWebRequest`、本地存储协同使用时效果很好。

## 4. `Unity Job System + Burst Compiler`

### 原理：

- Unity 官方多线程解决方案，使用原生 Job API 和 SIMD 编译器（Burst）进行多线程并行处理。
- 数据驱动设计，避免共享数据，最大化性能。

```
csharp复制编辑[BurstCompile]
public struct MyJob : IJob
{
    public void Execute() {
        // Do something
    }
}

// Schedule
MyJob job = new MyJob();
JobHandle handle = job.Schedule();
handle.Complete();
```

### 优点：

- 高性能，数据并行。
- 与 ECS 完美整合。
- 支持 SIMD 编译，极致优化。

### 缺点：

- 学习成本高，开发模式与传统面向对象不同。
- 不支持引用类型（只能用原始值类型+Native容器）。
- 调试麻烦，错误难定位。

### 适用场景：

- 大量数据的并行处理，如 AI 批量运算、路径搜索、粒子系统、地形生成等。
- 与 ECS、DOTS 架构协同使用效果最佳。

## 5. 第三方方案（如 UniTask）

### 原理：

- 基于 C# 的 `async/await` 语法封装，优化 Unity 场景中的协程和异步任务。

```
csharp复制编辑using Cysharp.Threading.Tasks;

async UniTaskVoid Example() {
    await UniTask.Delay(1000);
}
```

### 优点：

- `async/await` 语法糖，兼容 Unity 主线程操作。
- 支持取消、超时、调度器控制。
- 性能远优于原生协程。

### 缺点：

- 需要引入第三方库。
- 上手成本略高。

### 适用场景：

- 替代传统协程（`IEnumerator`）。
- UI 动画、过渡效果、异步加载、等待等逻辑。

## 📌 总结对比

| 方案                 | 控制能力 | 性能 | 易用性 | 适合任务           |
| -------------------- | -------- | ---- | ------ | ------------------ |
| `Thread`             | 高       | 中   | 低     | 长任务，线程控制   |
| `ThreadPool`         | 低       | 中高 | 中     | 短任务，频繁触发   |
| `Task / async-await` | 中       | 高   | 高     | 通用异步处理       |
| `Job System + Burst` | 中低     | 极高 | 低     | 数据并行，大量计算 |
| `UniTask`            | 中       | 高   | 极高   | Unity 中的异步协程 |

------

如果你是在做教学类视频、需要高效利用 CPU 算力，可以优先考虑：

- CPU 计算相关逻辑放在 `Task` / `ThreadPool`；
- 如果做游戏或引擎开发，并且数据处理密集，考虑 Unity Job System；
- UI/流程控制的异步推荐用 `UniTask` 替代协程。

如果你具体有哪一块想深挖（比如 Job System、UniTask 实战、异步纹理加载等），我也可以帮你做详细展开。